### Apriori

1. 首先根据`user_log_format1.csv`构造交易列表，由于`user_log_format1.csv`数据量太大，这里只取了交易列表中的`16*1024`条进行下一步计算。

2. 通过下面的伪代码进行计算

   ```c++
   L1 = {frequent items};
   for (k = 1; Lk !=∅; k++) do begin
   	Ck+1 = candidates generated from Lk;
   	for each transaction t in database do
   		increment the count of all candidates in Ck+1 that are contained in t
   		Lk+1 = candidates in Ck+1 with min_support
   	end
   return ∪k Lk;
   ```

3. 具体实现过程中的一些优化：

   1. 在计算频繁k项集时，可以将交易列表长度小于k的所有记录删除。因为长度小于k的记录一定不包含频繁k项集。
   2. 可以将商品id转换为整型值，然后将每条交易记录的商品id排序，在计算频繁k项集的时候可以直接比较整型值而非字符串。



### SOM

这里用SOM网络进行基于用户行为的聚类。SOM全称：自组织特征映射（Self Organizing feature Map），它可以保留在高维度空间下簇之间的拓扑关系并将这种拓扑关系映射至低维度（通常是一维或者二维），它是一种非监督性的竞争型神经网络。（这里可以再找一点点资料介绍一下，[参考](http://blog.csdn.net/xbinworld/article/details/50818803)，不过最好能找到wikipedia或者原论文）。

1. 首先根据`user_log_format1.csv`构造用户行为。这个表中的`action_type`字段记录了用户对商品的行为：

   ```
   0 - 用户点击该商品
   1 - 用户将该商品加入了购物车
   2 - 用户购买了该商品
   3 - 用户将该商品加入喜欢列表
   ```

   可以将这个字段下的记录当做用户对该商品的喜好程度的分值。在这里，将所有的用户行为自增1，并将用户对该商品无上述行为标记为0，即

   ```
   0 - 用户对该商品无操作
   1 - 用户点击该商品
   2 - 用户将该商品加入了购物车
   3 - 用户购买了该商品
   4 - 用户将该商品加入喜欢列表
   ```

   以此构造一个|U|\*|I|稀疏矩阵M，其中U代表用户集合，I代表商品集合。M\_{a,\*}代表第a个用户对所有商品的行为，M\_{\*,b}代表所有用户对第b个商品的行为，M\_{a,b}代表第a个用户对第b个商品的行为，取值为0-4。

   由于计算量大，这里只取512个用户进行聚类，即|U|=512。

2. 确定输出的维度、粒度、初始学习速率η和初始学习半径r，这里取输出维度为二维，粒度为50\*50。这里的50\*50指的是SOM输出层有2500个神经元，最后将输出一张50*50的热度图，表示用户的聚类拓扑关系热度图。

3. 随机生成一个2500\*|I|的权重矩阵，代表每个输出神经元对应的权重向量，类似于一个用户的行为向量。

4. 当输入一条记录时，使用距离计算公式（欧氏距离或者余弦距离等）计算与该记录距离最“近”的获胜神经元，以获胜神经元为中心，学习半径r内的所有神经元作为优胜邻域N_{j∗}(t)。对优胜邻域内的所有神经元使用以下公式调整权重
   $$
   w_{i,j}(t+1)=w_{i,j}(t)+η(t,N)[x−w_{i,j}(t)]
   $$
   其中每次迭代需要使用以下公式计算当次学习速率
   $$
   η(t,N)=η(t)e^{−N}
   $$
   式中，η(t,N)是训练时间t和优胜邻域内第j个神经元与获胜神经元之间的拓扑距离N的函数，其中η(t)可采用单调递减函数，即
   $$
   η(t)=η_0*(1-\frac{t}{total\_iter\_number})
   $$
   距离函数与学习半径有关，而学习半径也将采用单调递减函数。

5. 最终以热力图的方式展现聚类拓扑结构。